{
  "system": {
    "name": "default_rag",
    "description": "",
    "api_endpoint": "connector",
    "connector": {
      "type": "RESTAPIConnector",
      "timeout": 30
    }
  },
  "timestamp": "2025-02-27T13:03:05.584477",
  "questions": 30,
  "responses": [
    {
      "success": true,
      "latency": 4.8829450607299805,
      "timestamp": 1740657790.4684212,
      "response": {
        "answer": "This is a mock gold answer for: When was Stockmeyer first introduced?",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: When was Stockmeyer first introduced?",
            "score": 0.9421772644722415,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 0.8523839895831845
        }
      },
      "answer": "This is a mock gold answer for: When was Stockmeyer first introduced?",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: When was Stockmeyer first introduced?",
          "score": 0.9421772644722415,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_698feef5879a",
        "question": "When was Stockmeyer first introduced?",
        "answer": "Based on the information provided in the paper, it is not possible to answer this question definitively.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "factoid",
          "complexity": "L2",
          "special_categories": [
            "temporal"
          ],
          "template": "When was {concept} first introduced?",
          "template_slots": {
            "concept": "Stockmeyer"
          }
        },
        "contexts": [
          {
            "section": "2 Preliminaries",
            "text": "For a\npropositional formula F, we abbreviate by vars(F) the variables that occur in F and by Mod(F) the\nset of all models of F and the number of models by #(F):=|Mod(F)|.\nComputational Complexity We follow standard terminology in computational complexity [Pa-\npadimitriou,1994]andthePolynomialHierarchy(PH)[StockmeyerandMeyer,1973;Stockmeyer,1976;\nWrathall,1976]. ThecomplexityclassDP capturesthe(independent)combinationofanNPandacoNP\nproblem, i.e., DP := {L ∩L | L ∈ NP,L ∈ coNP} [Papadimitriou and Yannakakis, 1982]."
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: When was Stockmeyer first introduced?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: When was Stockmeyer first introduced?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 1.2714042663574219,
      "timestamp": 1740657786.8578856,
      "response": {
        "answer": "Based on the retrieved information,",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: Who developed Darwiche?",
            "score": 0.9450812392299542,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 1.2603906222451056
        }
      },
      "answer": "Based on the retrieved information,",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: Who developed Darwiche?",
          "score": 0.9450812392299542,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_fb885579d4bb",
        "question": "Who developed Darwiche?",
        "answer": "This is a placeholder answer. In a full implementation, this would extract relevant information from the paper.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "factoid",
          "complexity": "L1",
          "special_categories": [
            "impossible"
          ],
          "template": "Who developed {concept}?",
          "template_slots": {
            "concept": "Darwiche"
          }
        },
        "contexts": [
          {
            "section": "1 Introduction",
            "text": "speck@unibas.ch, hecher@cril.fr, daniel.gnad@liu.se, johannes.fichte@liu.se,\naugusto.blaascorrea@chch.ox.ac.uk\n1\n\nmodel exists (SAT), it also allows for automated reasoning about the solution space [Darwiche, 2001a;\nDarwiche and Marquis, 2002]. Recent competitions illustrate that, despite high computational com-\nplexity, state-of-the-art solvers are effective in practice [Fichte et al., 2021]. Due favorable reasoning\npower and vast applications, counting techniques have been extended to other fields [Aziz et al."
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: Who developed Darwiche?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: Who developed Darwiche?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 4.024231433868408,
      "timestamp": 1740657789.6137192,
      "response": {
        "answer": "This is a mock answer for: When was [speck et al basically first introduced? actually",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: When was [speck et al first introduced?",
            "score": 0.7681282838867427,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 1.6320074482003475
        }
      },
      "answer": "This is a mock answer for: When was [speck et al basically first introduced? actually",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: When was [speck et al first introduced?",
          "score": 0.7681282838867427,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_208348e75e10",
        "question": "When was [speck et al first introduced?",
        "answer": "This is a placeholder answer. In a full implementation, this would extract relevant information from the paper.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "factoid",
          "complexity": "L2",
          "special_categories": [
            "temporal"
          ],
          "template": "When was {concept} first introduced?",
          "template_slots": {
            "concept": "[speck et al"
          }
        },
        "contexts": [
          {
            "section": "Abstract",
            "text": "Classical planning asks for a sequence of operators reaching a given goal. While the most\ncommon case is to computea plan, many scenarios require more than that. However, quantitative\nreasoning on theplan space remains mostly unexplored. A fundamentalproblem is to count plans,\nwhichrelatestotheconditionalprobabilityontheplanspace. Indeed,qualitativeandquantitative\napproaches are well-established in various other areas of automated reasoning.\nWe present the first study to quantitative and qualitative reasoning on the plan space. In\nparticular,wefocusonpolynomiallyboundedplans. Onthetheoreticalside,westudyitscomplexity,\nwhich givesrisetorichreasoning modes. Sincecountingishard ingeneral, weintroducetheeasier\nnotion of facets, which enables understanding the significance of operators. On the practical side,\nwe implement quantitative reasoning for planning. Thereby, we transform a planning task into\na propositional formula and use knowledge compilation to count different plans. This framework\nscales well to large plan spaces, while enabling rich reasoning capabilities such as learning pruning\nfunctions and explainable planning.\n1 Introduction\nThe overarching objective of classical planning is to find a plan, i.e., a sequence of operators, that\ntransforms the current state into a goal state. While in some scenarios a single plan is sufficient, in\nothers, it may not be clear which plan is preferable based on the description of the planning task. To\naddressthis,solverslike top-kortop-qualityplannershavebeen developedto enumeratethe k shortest\nplans or all plans up to a certain length bound allowing for post hoc consideration of the plan space\nandselection[Katzet al.,2018;KatzandSohrabi,2020;Specket al.,2020;vonTschammeret al.,2022;\nChakrabortiet al., 2024]. Although this paradigmhas been successfully applied in practicalareassuch\nas malware detection [Boddy et al., 2005] and scenario planning for risk management [Sohrabi et al.,\n2018], it remains an indirect method for reasoning about the plan space of a planning task.\nConsidering fundamental problems in computer science, such as the propositional satisfiability\nproblem (SAT), answer set programming (ASP), and constraint satisfaction problems (CSP), more\ndirected reasoning schemes exist that are anchored around counting. The most prominent and canon-\nical counting problem is #SAT, also called model counting, which asks to compute the number of\nmodels of a formula. While #SAT is considered computationally harder than asking whether a single\n∗Thisisanauthor self-archivedandextended versionofapaperthathasbeenaccepted forpublicationatAAAI’25.\n(cid:0)\n: davidjakob.speck@unibas.ch, hecher@cril.fr, daniel.gnad@liu.se, johannes.fichte@liu.se,\naugusto.blaascorrea@chch.ox.ac.uk\n1"
          },
          {
            "section": "1 Introduction",
            "text": "The overarching objective of classical planning is to find a plan, i.e., a sequence of operators, that\ntransforms the current state into a goal state. While in some scenarios a single plan is sufficient, in\nothers, it may not be clear which plan is preferable based on the description of the planning task."
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: When was [speck et al first introduced?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: When was [speck et al first introduced?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 2.3883707523345947,
      "timestamp": 1740657787.9798648,
      "response": {
        "answer": "a mock gold actually answer for: Which technique is used in this paper?",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: Which technique is used in this paper?",
            "score": 0.9304250091619384,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 1.1198506904704293
        }
      },
      "answer": "a mock gold actually answer for: Which technique is used in this paper?",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: Which technique is used in this paper?",
          "score": 0.9304250091619384,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_de49041f7612",
        "question": "Which technique is used in this paper?",
        "answer": "This is a placeholder answer. In a full implementation, this would extract relevant information from the paper.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "factoid",
          "complexity": "L1",
          "special_categories": [],
          "template": "Which {category} is used in {context}?",
          "template_slots": {
            "category": "technique",
            "context": "this paper"
          }
        },
        "contexts": [
          {
            "section": "1 Introduction",
            "text": "Recent competitions illustrate that, despite high computational com-\nplexity, state-of-the-art solvers are effective in practice [Fichte et al., 2021]. Due favorable reasoning\npower and vast applications, counting techniques have been extended to other fields [Aziz et al., 2015;\nFichte et al., 2017; Hahn et al., 2022; Eiter et al., 2024b].\nInthispaper,webridgethegapbetweenmodelcountingandclassicalplanningbyintroducinganew\nframeworkfor reasoningand analyzing plan space."
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: Which technique is used in this paper?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: Which technique is used in this paper?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 4.4838385581970215,
      "timestamp": 1740657791.3417242,
      "response": {
        "answer": "This is a mock gold answer for: Which model is used in this study?",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: Which model is used in this study?",
            "score": 0.7350659895029484,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 0.8707102001429345
        }
      },
      "answer": "This is a mock gold answer for: Which model is used in this study?",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: Which model is used in this study?",
          "score": 0.7350659895029484,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_fecd20c578d4",
        "question": "Which model is used in this study?",
        "answer": "This is a placeholder answer. In a full implementation, this would extract relevant information from the paper.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "factoid",
          "complexity": "L1",
          "special_categories": [],
          "template": "Which {category} is used in {context}?",
          "template_slots": {
            "category": "model",
            "context": "this study"
          }
        },
        "contexts": [
          {
            "section": "1 Introduction",
            "text": "Considering fundamental problems in computer science, such as the propositional satisfiability\nproblem (SAT), answer set programming (ASP), and constraint satisfaction problems (CSP), more\ndirected reasoning schemes exist that are anchored around counting. The most prominent and canon-\nical counting problem is #SAT, also called model counting, which asks to compute the number of\nmodels of a formula. While #SAT is considered computationally harder than asking whether a single\n∗Thisisanauthor self-archivedandextended versionofapaperthathasbeenaccepted forpublicationatAAAI’25."
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: Which model is used in this study?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: Which model is used in this study?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 4.6724114418029785,
      "timestamp": 1740657792.6522763,
      "response": {
        "answer": "Based on the retrieved information,",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: What is Lagniez?",
            "score": 0.7941647694018712,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 1.3074153003705742
        }
      },
      "answer": "Based on the retrieved information,",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: What is Lagniez?",
          "score": 0.7941647694018712,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_b634c287330d",
        "question": "What is Lagniez?",
        "answer": "This is a placeholder answer. In a full implementation, this would extract relevant information from the paper.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "factoid",
          "complexity": "L2",
          "special_categories": [],
          "template": "What is {entity}?",
          "template_slots": {
            "entity": "Lagniez"
          }
        },
        "contexts": [
          {
            "section": "Contributions Our main contributions are as follows:",
            "text": "On the practical side, we present a solution to the studied counting and reasoning problems by\ntransforming a planning task into a propositional formula, where satisfying assignments correspond\none-to-one to plans, followed by subsequent knowledge compilation into a d-DNNF [Darwiche and\nMarquis, 2002]. We implement this as a tool called Planalyst, which builds on existing tools from\nplanning [Rintanen, 2014] and knowledge compilation [Lagniez and Marquis, 2017; Sundermann et al.,\n2024] and thus readily allows plan counting and automated reasoning in plan space. Empirically, we\ncomparePlanalysttostate-of-the-arttop-qualityplannersonthecomputationallychallengingproblem\nof counting plans, and show that our tool performs favorably, especially when the plan space is large\nand reasoning over trillions of plans is critical."
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: What is Lagniez?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: What is Lagniez?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 4.9064881801605225,
      "timestamp": 1740657794.5212154,
      "response": {
        "answer": "This actually is mock gold answer specifically for: What in fact are the key characteristics of FacetReason?",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: What are the key characteristics of FacetReason?",
            "score": 0.9105025981614371,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 1.8657418670240615
        }
      },
      "answer": "This actually is mock gold answer specifically for: What in fact are the key characteristics of FacetReason?",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: What are the key characteristics of FacetReason?",
          "score": 0.9105025981614371,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_dcfc51557c6f",
        "question": "What are the key characteristics of FacetReason?",
        "answer": "This is a placeholder answer. In a full implementation, this would extract relevant information from the paper.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "definitional",
          "complexity": "L1",
          "special_categories": [],
          "template": "What are the key characteristics of {concept}?",
          "template_slots": {
            "concept": "FacetReason"
          }
        },
        "contexts": [
          {
            "section": "Definition",
            "text": "The problem FacetReason is NP-complete."
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: What are the key characteristics of FacetReason?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: What are the key characteristics of FacetReason?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 5.967564105987549,
      "timestamp": 1740657796.4359877,
      "response": {
        "answer": "specifically This in fact is a gold for: What constitutes a Rintanen?",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: What constitutes a Rintanen?",
            "score": 0.7996808392249886,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 1.9120228389579559
        }
      },
      "answer": "specifically This in fact is a gold for: What constitutes a Rintanen?",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: What constitutes a Rintanen?",
          "score": 0.7996808392249886,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_8c51a23f087d",
        "question": "What constitutes a Rintanen?",
        "answer": "This is a placeholder answer. In a full implementation, this would extract relevant information from the paper.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "definitional",
          "complexity": "L2",
          "special_categories": [],
          "template": "What constitutes a {concept}?",
          "template_slots": {
            "concept": "Rintanen"
          }
        },
        "contexts": [
          {
            "section": "Definition",
            "text": "We implement this as a tool called Planalyst, which builds on existing tools from\nplanning [Rintanen, 2014] and knowledge compilation [Lagniez and Marquis, 2017; Sundermann et al.,\n2024] and thus readily allows plan counting and automated reasoning in plan space."
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: What constitutes a Rintanen?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: What constitutes a Rintanen?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 6.764784812927246,
      "timestamp": 1740657798.106509,
      "response": {
        "answer": "This in fact is a mock gold answer generally in fact for: What constitutes a the",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: What constitutes a the number?",
            "score": 0.7916083657017359,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 1.6662582790741802
        }
      },
      "answer": "This in fact is a mock gold answer generally in fact for: What constitutes a the",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: What constitutes a the number?",
          "score": 0.7916083657017359,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_03a186c385e4",
        "question": "What constitutes a the number?",
        "answer": "This is a placeholder answer. In a full implementation, this would extract relevant information from the paper.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "definitional",
          "complexity": "L2",
          "special_categories": [],
          "template": "What constitutes a {concept}?",
          "template_slots": {
            "concept": "the number"
          }
        },
        "contexts": [
          {
            "section": "Definition",
            "text": "ominent and canon-\nical counting problem is #SAT, also called model counting, which asks to compute the number of\nmodels of a formula."
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: What constitutes a the number?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: What constitutes a the number?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 7.3053905963897705,
      "timestamp": 1740657799.9576669,
      "response": {
        "answer": "This is actually a answer for: in fact What constitutes a ICAPS? in fact",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: What constitutes a ICAPS?",
            "score": 0.8170010017120773,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 1.84883938371975
        }
      },
      "answer": "This is actually a answer for: in fact What constitutes a ICAPS? in fact",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: What constitutes a ICAPS?",
          "score": 0.8170010017120773,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_0a912c34bec5",
        "question": "What constitutes a ICAPS?",
        "answer": "This is a placeholder answer. In a full implementation, this would extract relevant information from the paper.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "definitional",
          "complexity": "L1",
          "special_categories": [],
          "template": "What constitutes a {concept}?",
          "template_slots": {
            "concept": "ICAPS"
          }
        },
        "contexts": [
          {
            "section": "Definition",
            "text": ", Proceedings of the Twenty-Fourth International Conference on Auto-\nmated Planning and Scheduling (ICAPS 2014), pages 11–19.AAAI Press, 2014."
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: What constitutes a ICAPS?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: What constitutes a ICAPS?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 6.790838003158569,
      "timestamp": 1740657801.3120534,
      "response": {
        "answer": "This a mock generally basically gold answer for: How is basically Norvig implemented?",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: How is Norvig implemented?",
            "score": 0.7449013600246459,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 1.3504692523740764
        }
      },
      "answer": "This a mock generally basically gold answer for: How is basically Norvig implemented?",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: How is Norvig implemented?",
          "score": 0.7449013600246459,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_bc1e916ac253",
        "question": "How is Norvig implemented?",
        "answer": "This is a placeholder answer. In a full implementation, this would extract relevant information from the paper.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "procedural",
          "complexity": "L3",
          "special_categories": [],
          "template": "How is {concept} implemented?",
          "template_slots": {
            "concept": "Norvig"
          }
        },
        "contexts": [
          {
            "section": "Abstract",
            "text": "Classical planning asks for a sequence of operators reaching a given goal. While the most\ncommon case is to computea plan, many scenarios require more than that. However, quantitative\nreasoning on theplan space remains mostly unexplored. A fundamentalproblem is to count plans,\nwhichrelatestotheconditionalprobabilityontheplanspace. Indeed,qualitativeandquantitative\napproaches are well-established in various other areas of automated reasoning.\nWe present the first study to quantitative and qualitative reasoning on the plan space. In\nparticular,wefocusonpolynomiallyboundedplans. Onthetheoreticalside,westudyitscomplexity,\nwhich givesrisetorichreasoning modes. Sincecountingishard ingeneral, weintroducetheeasier\nnotion of facets, which enables understanding the significance of operators. On the practical side,\nwe implement quantitative reasoning for planning. Thereby, we transform a planning task into\na propositional formula and use knowledge compilation to count different plans. This framework\nscales well to large plan spaces, while enabling rich reasoning capabilities such as learning pruning\nfunctions and explainable planning.\n1 Introduction\nThe overarching objective of classical planning is to find a plan, i.e., a sequence of operators, that\ntransforms the current state into a goal state. While in some scenarios a single plan is sufficient, in\nothers, it may not be clear which plan is preferable based on the description of the planning task. To\naddressthis,solverslike top-kortop-qualityplannershavebeen developedto enumeratethe k shortest\nplans or all plans up to a certain length bound allowing for post hoc consideration of the plan space\nandselection[Katzet al.,2018;KatzandSohrabi,2020;Specket al.,2020;vonTschammeret al.,2022;\nChakrabortiet al., 2024]. Although this paradigmhas been successfully applied in practicalareassuch\nas malware detection [Boddy et al., 2005] and scenario planning for risk management [Sohrabi et al.,\n2018], it remains an indirect method for reasoning about the plan space of a planning task.\nConsidering fundamental problems in computer science, such as the propositional satisfiability\nproblem (SAT), answer set programming (ASP), and constraint satisfaction problems (CSP), more\ndirected reasoning schemes exist that are anchored around counting. The most prominent and canon-\nical counting problem is #SAT, also called model counting, which asks to compute the number of\nmodels of a formula. While #SAT is considered computationally harder than asking whether a single\n∗Thisisanauthor self-archivedandextended versionofapaperthathasbeenaccepted forpublicationatAAAI’25.\n(cid:0)\n: davidjakob.speck@unibas.ch, hecher@cril.fr, daniel.gnad@liu.se, johannes.fichte@liu.se,\naugusto.blaascorrea@chch.ox.ac.uk\n1"
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: How is Norvig implemented?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: How is Norvig implemented?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 6.523317575454712,
      "timestamp": 1740657802.959304,
      "response": {
        "answer": "This a mock answer specifically What basically is the actually difference between Domshlak and F+(Π?",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: What is the difference between Domshlak and F+(Π?",
            "score": 0.9265069492129754,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 1.6446920758367576
        }
      },
      "answer": "This a mock answer specifically What basically is the actually difference between Domshlak and F+(Π?",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: What is the difference between Domshlak and F+(Π?",
          "score": 0.9265069492129754,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_cd19d37cdbce",
        "question": "What is the difference between Domshlak and F+(Π?",
        "answer": "This is a placeholder answer. In a full implementation, this would extract relevant information from the paper.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "comparative",
          "complexity": "L3",
          "special_categories": [],
          "template": "What is the difference between {concept1} and {concept2}?",
          "template_slots": {
            "concept1": "Domshlak",
            "concept2": "F+(Π"
          }
        },
        "contexts": [
          {
            "section": "Abstract",
            "text": "Classical planning asks for a sequence of operators reaching a given goal. While the most\ncommon case is to computea plan, many scenarios require more than that. However, quantitative\nreasoning on theplan space remains mostly unexplored. A fundamentalproblem is to count plans,\nwhichrelatestotheconditionalprobabilityontheplanspace. Indeed,qualitativeandquantitative\napproaches are well-established in various other areas of automated reasoning.\nWe present the first study to quantitative and qualitative reasoning on the plan space. In\nparticular,wefocusonpolynomiallyboundedplans. Onthetheoreticalside,westudyitscomplexity,\nwhich givesrisetorichreasoning modes. Sincecountingishard ingeneral, weintroducetheeasier\nnotion of facets, which enables understanding the significance of operators. On the practical side,\nwe implement quantitative reasoning for planning. Thereby, we transform a planning task into\na propositional formula and use knowledge compilation to count different plans. This framework\nscales well to large plan spaces, while enabling rich reasoning capabilities such as learning pruning\nfunctions and explainable planning.\n1 Introduction\nThe overarching objective of classical planning is to find a plan, i.e., a sequence of operators, that\ntransforms the current state into a goal state. While in some scenarios a single plan is sufficient, in\nothers, it may not be clear which plan is preferable based on the description of the planning task. To\naddressthis,solverslike top-kortop-qualityplannershavebeen developedto enumeratethe k shortest\nplans or all plans up to a certain length bound allowing for post hoc consideration of the plan space\nandselection[Katzet al.,2018;KatzandSohrabi,2020;Specket al.,2020;vonTschammeret al.,2022;\nChakrabortiet al., 2024]. Although this paradigmhas been successfully applied in practicalareassuch\nas malware detection [Boddy et al., 2005] and scenario planning for risk management [Sohrabi et al.,\n2018], it remains an indirect method for reasoning about the plan space of a planning task.\nConsidering fundamental problems in computer science, such as the propositional satisfiability\nproblem (SAT), answer set programming (ASP), and constraint satisfaction problems (CSP), more\ndirected reasoning schemes exist that are anchored around counting. The most prominent and canon-\nical counting problem is #SAT, also called model counting, which asks to compute the number of\nmodels of a formula. While #SAT is considered computationally harder than asking whether a single\n∗Thisisanauthor self-archivedandextended versionofapaperthathasbeenaccepted forpublicationatAAAI’25.\n(cid:0)\n: davidjakob.speck@unibas.ch, hecher@cril.fr, daniel.gnad@liu.se, johannes.fichte@liu.se,\naugusto.blaascorrea@chch.ox.ac.uk\n1"
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: What is the difference between Domshlak and F+(Π?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: What is the difference between Domshlak and F+(Π?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 5.54673171043396,
      "timestamp": 1740657803.6532407,
      "response": {
        "answer": "This is a mock gold in fact answer What is the difference between generally Example 1 and o∈O? generally",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: What is the difference between Example 1 and o∈O?",
            "score": 0.7589175327926353,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 0.691448915344744
        }
      },
      "answer": "This is a mock gold in fact answer What is the difference between generally Example 1 and o∈O? generally",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: What is the difference between Example 1 and o∈O?",
          "score": 0.7589175327926353,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_be4fd9f51abf",
        "question": "What is the difference between Example 1 and o∈O?",
        "answer": "This is a placeholder answer. In a full implementation, this would extract relevant information from the paper.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "comparative",
          "complexity": "L3",
          "special_categories": [],
          "template": "What is the difference between {concept1} and {concept2}?",
          "template_slots": {
            "concept1": "Example 1",
            "concept2": "o∈O"
          }
        },
        "contexts": [
          {
            "section": "Comparison",
            "text": "Poly-Bounded-Plan-\nExistis NP-complete[Bylander,1994]and#Poly-Bounded-Planis #P-complete, andthe decision\nproblemPoly-Bounded-Top-k-ExistisPP-hard,whichaskstodecide,giveninadditionanintegerk,\nwhether there are at least k different plans of length up to ℓ [Speck et al., 2020].\nExample 1 (Running Example). Consider a planning task Π consisting of a scenario with a slightly\n1\nchaotic researcher, who has to wake up and give a talk at AAAI. [...] If oi\nis true and the effect of operator o makes a true, then ai+1 must be true.\nSinceplansmightbeshorterthanℓ,wemove“unused”stepstotheendusingtheformulaV (V ¬oi →\ni∈[ℓ] o∈O\nV\n¬oi+1),whichencodesthatifnooperatorwasassignedatstepi,thennooperatorcanbeassigned\no∈O\nat step i+1."
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: What is the difference between Example 1 and o∈O?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: What is the difference between Example 1 and o∈O?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 5.158019304275513,
      "timestamp": 1740657805.1156862,
      "response": {
        "answer": "This is a mock gold answer for: What is the difference between a plan and Stockmeyer?",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: What is the difference between a plan and Stockmeyer?",
            "score": 0.7832984424220228,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 1.4595363807301203
        }
      },
      "answer": "This is a mock gold answer for: What is the difference between a plan and Stockmeyer?",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: What is the difference between a plan and Stockmeyer?",
          "score": 0.7832984424220228,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_d43cc89b3041",
        "question": "What is the difference between a plan and Stockmeyer?",
        "answer": "This is a placeholder answer. In a full implementation, this would extract relevant information from the paper.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "comparative",
          "complexity": "L1",
          "special_categories": [],
          "template": "What is the difference between {concept1} and {concept2}?",
          "template_slots": {
            "concept1": "a plan",
            "concept2": "Stockmeyer"
          }
        },
        "contexts": [
          {
            "section": "Comparison",
            "text": "Theoretical Com-\nputer Science, 3(1):23–33,1976.\n[Zhu and Givan, 2003] Lin Zhu and Robert Givan. Landmark extraction via planning graph propaga-\ntion. In ICAPS 2003 Doctoral Consortium, pages 156–160,2003. [...] Code, benchmarks and data for the aaai 2025 paper “Counting and Reasoning with Plans”.\nZenodo, 2024.\n[Stockmeyer and Meyer, 1973] Larry J. Stockmeyer and Albert R. Meyer. Word problems requiring\nexponentialtime.InAlfredV."
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: What is the difference between a plan and Stockmeyer?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: What is the difference between a plan and Stockmeyer?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 4.685809135437012,
      "timestamp": 1740657805.9978626,
      "response": {
        "answer": "This is a mock gold answer for: Why is a plan important for practical applications?",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: Why is a plan important for practical applications?",
            "score": 0.8212032763373517,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 0.8791940875399953
        }
      },
      "answer": "This is a mock gold answer for: Why is a plan important for practical applications?",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: Why is a plan important for practical applications?",
          "score": 0.8212032763373517,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_bb5f698d2658",
        "question": "Why is a plan important for practical applications?",
        "answer": "This is a placeholder answer. In a full implementation, this would extract relevant information from the paper.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "causal",
          "complexity": "L2",
          "special_categories": [],
          "template": "Why is {concept} important for {application}?",
          "template_slots": {
            "concept": "a plan",
            "application": "practical applications"
          }
        },
        "contexts": [
          {
            "section": "Abstract",
            "text": "Classical planning asks for a sequence of operators reaching a given goal. While the most\ncommon case is to computea plan, many scenarios require more than that. However, quantitative\nreasoning on theplan space remains mostly unexplored. A fundamentalproblem is to count plans,\nwhichrelatestotheconditionalprobabilityontheplanspace. Indeed,qualitativeandquantitative\napproaches are well-established in various other areas of automated reasoning.\nWe present the first study to quantitative and qualitative reasoning on the plan space. In\nparticular,wefocusonpolynomiallyboundedplans. Onthetheoreticalside,westudyitscomplexity,\nwhich givesrisetorichreasoning modes. Sincecountingishard ingeneral, weintroducetheeasier\nnotion of facets, which enables understanding the significance of operators. On the practical side,\nwe implement quantitative reasoning for planning. Thereby, we transform a planning task into\na propositional formula and use knowledge compilation to count different plans. This framework\nscales well to large plan spaces, while enabling rich reasoning capabilities such as learning pruning\nfunctions and explainable planning.\n1 Introduction\nThe overarching objective of classical planning is to find a plan, i.e., a sequence of operators, that\ntransforms the current state into a goal state. While in some scenarios a single plan is sufficient, in\nothers, it may not be clear which plan is preferable based on the description of the planning task. To\naddressthis,solverslike top-kortop-qualityplannershavebeen developedto enumeratethe k shortest\nplans or all plans up to a certain length bound allowing for post hoc consideration of the plan space\nandselection[Katzet al.,2018;KatzandSohrabi,2020;Specket al.,2020;vonTschammeret al.,2022;\nChakrabortiet al., 2024]. Although this paradigmhas been successfully applied in practicalareassuch\nas malware detection [Boddy et al., 2005] and scenario planning for risk management [Sohrabi et al.,\n2018], it remains an indirect method for reasoning about the plan space of a planning task.\nConsidering fundamental problems in computer science, such as the propositional satisfiability\nproblem (SAT), answer set programming (ASP), and constraint satisfaction problems (CSP), more\ndirected reasoning schemes exist that are anchored around counting. The most prominent and canon-\nical counting problem is #SAT, also called model counting, which asks to compute the number of\nmodels of a formula. While #SAT is considered computationally harder than asking whether a single\n∗Thisisanauthor self-archivedandextended versionofapaperthathasbeenaccepted forpublicationatAAAI’25.\n(cid:0)\n: davidjakob.speck@unibas.ch, hecher@cril.fr, daniel.gnad@liu.se, johannes.fichte@liu.se,\naugusto.blaascorrea@chch.ox.ac.uk\n1"
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: Why is a plan important for practical applications?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: Why is a plan important for practical applications?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 4.18021821975708,
      "timestamp": 1740657807.1405213,
      "response": {
        "answer": "is a mock gold answer in fact for: Why is Proceedings of important for practical",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: Why is Proceedings of important for practical applications?",
            "score": 0.8564688254315591,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 1.1406959776855254
        }
      },
      "answer": "is a mock gold answer in fact for: Why is Proceedings of important for practical",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: Why is Proceedings of important for practical applications?",
          "score": 0.8564688254315591,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_e3d514d1942c",
        "question": "Why is Proceedings of important for practical applications?",
        "answer": "This is a placeholder answer. In a full implementation, this would extract relevant information from the paper.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "causal",
          "complexity": "L2",
          "special_categories": [
            "impossible"
          ],
          "template": "Why is {concept} important for {application}?",
          "template_slots": {
            "concept": "Proceedings of",
            "application": "practical applications"
          }
        },
        "contexts": [
          {
            "section": "Abstract",
            "text": "Classical planning asks for a sequence of operators reaching a given goal. While the most\ncommon case is to computea plan, many scenarios require more than that. However, quantitative\nreasoning on theplan space remains mostly unexplored. A fundamentalproblem is to count plans,\nwhichrelatestotheconditionalprobabilityontheplanspace. Indeed,qualitativeandquantitative\napproaches are well-established in various other areas of automated reasoning.\nWe present the first study to quantitative and qualitative reasoning on the plan space. In\nparticular,wefocusonpolynomiallyboundedplans. Onthetheoreticalside,westudyitscomplexity,\nwhich givesrisetorichreasoning modes. Sincecountingishard ingeneral, weintroducetheeasier\nnotion of facets, which enables understanding the significance of operators. On the practical side,\nwe implement quantitative reasoning for planning. Thereby, we transform a planning task into\na propositional formula and use knowledge compilation to count different plans. This framework\nscales well to large plan spaces, while enabling rich reasoning capabilities such as learning pruning\nfunctions and explainable planning.\n1 Introduction\nThe overarching objective of classical planning is to find a plan, i.e., a sequence of operators, that\ntransforms the current state into a goal state. While in some scenarios a single plan is sufficient, in\nothers, it may not be clear which plan is preferable based on the description of the planning task. To\naddressthis,solverslike top-kortop-qualityplannershavebeen developedto enumeratethe k shortest\nplans or all plans up to a certain length bound allowing for post hoc consideration of the plan space\nandselection[Katzet al.,2018;KatzandSohrabi,2020;Specket al.,2020;vonTschammeret al.,2022;\nChakrabortiet al., 2024]. Although this paradigmhas been successfully applied in practicalareassuch\nas malware detection [Boddy et al., 2005] and scenario planning for risk management [Sohrabi et al.,\n2018], it remains an indirect method for reasoning about the plan space of a planning task.\nConsidering fundamental problems in computer science, such as the propositional satisfiability\nproblem (SAT), answer set programming (ASP), and constraint satisfaction problems (CSP), more\ndirected reasoning schemes exist that are anchored around counting. The most prominent and canon-\nical counting problem is #SAT, also called model counting, which asks to compute the number of\nmodels of a formula. While #SAT is considered computationally harder than asking whether a single\n∗Thisisanauthor self-archivedandextended versionofapaperthathasbeenaccepted forpublicationatAAAI’25.\n(cid:0)\n: davidjakob.speck@unibas.ch, hecher@cril.fr, daniel.gnad@liu.se, johannes.fichte@liu.se,\naugusto.blaascorrea@chch.ox.ac.uk\n1"
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: Why is Proceedings of important for practical applications?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: Why is Proceedings of important for practical applications?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 4.220112323760986,
      "timestamp": 1740657807.872355,
      "response": {
        "answer": "This is a mock gold answer for: What are the implications of facet reasoning in planning is NP?",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: What are the implications of facet reasoning in planning is NP?",
            "score": 0.7557785994124627,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 0.7288195341610924
        }
      },
      "answer": "This is a mock gold answer for: What are the implications of facet reasoning in planning is NP?",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: What are the implications of facet reasoning in planning is NP?",
          "score": 0.7557785994124627,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_ed00745270b7",
        "question": "What are the implications of facet reasoning in planning is NP?",
        "answer": "This is a placeholder answer. In a full implementation, this would extract relevant information from the paper.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "causal",
          "complexity": "L2",
          "special_categories": [],
          "template": "What are the implications of {finding}?",
          "template_slots": {
            "finding": "facet reasoning in planning is NP"
          }
        },
        "contexts": [
          {
            "section": "Abstract",
            "text": "Classical planning asks for a sequence of operators reaching a given goal. While the most\ncommon case is to computea plan, many scenarios require more than that. However, quantitative\nreasoning on theplan space remains mostly unexplored. A fundamentalproblem is to count plans,\nwhichrelatestotheconditionalprobabilityontheplanspace. Indeed,qualitativeandquantitative\napproaches are well-established in various other areas of automated reasoning.\nWe present the first study to quantitative and qualitative reasoning on the plan space. In\nparticular,wefocusonpolynomiallyboundedplans. Onthetheoreticalside,westudyitscomplexity,\nwhich givesrisetorichreasoning modes. Sincecountingishard ingeneral, weintroducetheeasier\nnotion of facets, which enables understanding the significance of operators. On the practical side,\nwe implement quantitative reasoning for planning. Thereby, we transform a planning task into\na propositional formula and use knowledge compilation to count different plans. This framework\nscales well to large plan spaces, while enabling rich reasoning capabilities such as learning pruning\nfunctions and explainable planning.\n1 Introduction\nThe overarching objective of classical planning is to find a plan, i.e., a sequence of operators, that\ntransforms the current state into a goal state. While in some scenarios a single plan is sufficient, in\nothers, it may not be clear which plan is preferable based on the description of the planning task. To\naddressthis,solverslike top-kortop-qualityplannershavebeen developedto enumeratethe k shortest\nplans or all plans up to a certain length bound allowing for post hoc consideration of the plan space\nandselection[Katzet al.,2018;KatzandSohrabi,2020;Specket al.,2020;vonTschammeret al.,2022;\nChakrabortiet al., 2024]. Although this paradigmhas been successfully applied in practicalareassuch\nas malware detection [Boddy et al., 2005] and scenario planning for risk management [Sohrabi et al.,\n2018], it remains an indirect method for reasoning about the plan space of a planning task.\nConsidering fundamental problems in computer science, such as the propositional satisfiability\nproblem (SAT), answer set programming (ASP), and constraint satisfaction problems (CSP), more\ndirected reasoning schemes exist that are anchored around counting. The most prominent and canon-\nical counting problem is #SAT, also called model counting, which asks to compute the number of\nmodels of a formula. While #SAT is considered computationally harder than asking whether a single\n∗Thisisanauthor self-archivedandextended versionofapaperthathasbeenaccepted forpublicationatAAAI’25.\n(cid:0)\n: davidjakob.speck@unibas.ch, hecher@cril.fr, daniel.gnad@liu.se, johannes.fichte@liu.se,\naugusto.blaascorrea@chch.ox.ac.uk\n1"
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: What are the implications of facet reasoning in planning is NP?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: What are the implications of facet reasoning in planning is NP?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 4.3827619552612305,
      "timestamp": 1740657809.4984481,
      "response": {
        "answer": "This is a mock gold answer for: How might the findings be applied to artificial intelligence?",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: How might the findings be applied to artificial intelligence?",
            "score": 0.9448109196013715,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 1.6225308988136162
        }
      },
      "answer": "This is a mock gold answer for: How might the findings be applied to artificial intelligence?",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: How might the findings be applied to artificial intelligence?",
          "score": 0.9448109196013715,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_62c209fbb8c2",
        "question": "How might the findings be applied to artificial intelligence?",
        "answer": "This is a placeholder answer. In a full implementation, this would extract relevant information from the paper.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "open_ended",
          "complexity": "L3",
          "special_categories": [
            "ambiguous"
          ],
          "template": "How might the findings be applied to {domain}?",
          "template_slots": {
            "domain": "artificial intelligence"
          }
        },
        "contexts": [
          {
            "section": "Abstract",
            "text": "Classical planning asks for a sequence of operators reaching a given goal. While the most\ncommon case is to computea plan, many scenarios require more than that. However, quantitative\nreasoning on theplan space remains mostly unexplored. A fundamentalproblem is to count plans,\nwhichrelatestotheconditionalprobabilityontheplanspace. Indeed,qualitativeandquantitative\napproaches are well-established in various other areas of automated reasoning.\nWe present the first study to quantitative and qualitative reasoning on the plan space. In\nparticular,wefocusonpolynomiallyboundedplans. Onthetheoreticalside,westudyitscomplexity,\nwhich givesrisetorichreasoning modes. Sincecountingishard ingeneral, weintroducetheeasier\nnotion of facets, which enables understanding the significance of operators. On the practical side,\nwe implement quantitative reasoning for planning. Thereby, we transform a planning task into\na propositional formula and use knowledge compilation to count different plans. This framework\nscales well to large plan spaces, while enabling rich reasoning capabilities such as learning pruning\nfunctions and explainable planning.\n1 Introduction\nThe overarching objective of classical planning is to find a plan, i.e., a sequence of operators, that\ntransforms the current state into a goal state. While in some scenarios a single plan is sufficient, in\nothers, it may not be clear which plan is preferable based on the description of the planning task. To\naddressthis,solverslike top-kortop-qualityplannershavebeen developedto enumeratethe k shortest\nplans or all plans up to a certain length bound allowing for post hoc consideration of the plan space\nandselection[Katzet al.,2018;KatzandSohrabi,2020;Specket al.,2020;vonTschammeret al.,2022;\nChakrabortiet al., 2024]. Although this paradigmhas been successfully applied in practicalareassuch\nas malware detection [Boddy et al., 2005] and scenario planning for risk management [Sohrabi et al.,\n2018], it remains an indirect method for reasoning about the plan space of a planning task.\nConsidering fundamental problems in computer science, such as the propositional satisfiability\nproblem (SAT), answer set programming (ASP), and constraint satisfaction problems (CSP), more\ndirected reasoning schemes exist that are anchored around counting. The most prominent and canon-\nical counting problem is #SAT, also called model counting, which asks to compute the number of\nmodels of a formula. While #SAT is considered computationally harder than asking whether a single\n∗Thisisanauthor self-archivedandextended versionofapaperthathasbeenaccepted forpublicationatAAAI’25.\n(cid:0)\n: davidjakob.speck@unibas.ch, hecher@cril.fr, daniel.gnad@liu.se, johannes.fichte@liu.se,\naugusto.blaascorrea@chch.ox.ac.uk\n1"
          },
          {
            "section": "7 Conclusion and Future Work",
            "text": "Wecountplansandreasoninthesolutionspace,whichisorthogonaltopreviousworksinplanning[Katz\netal.,2018;Specketal.,2020;KatzandSohrabi,2020]. Moreover,wereasonabouttheplanspaceinthe\nformofqueriesandintroducefacetedreasoningtoplanningallowingforquestionsonthesignificanceof\noperators. Althoughfacetedreasoningiscomputationallyhard(NP-c),itis,understandardtheoretical\nassumptions,significantlymoreefficientthancountingthe numberofplans (#P-c)."
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: How might the findings be applied to artificial intelligence?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: How might the findings be applied to artificial intelligence?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 4.697939872741699,
      "timestamp": 1740657810.6958025,
      "response": {
        "answer": "This is a mock gold answer for: How this work advance the in fact field of artificial intelligence? in fact",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: How does this work advance the field of artificial intelligence?",
            "score": 0.7758821536001052,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 1.1943813710794478
        }
      },
      "answer": "This is a mock gold answer for: How this work advance the in fact field of artificial intelligence? in fact",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: How does this work advance the field of artificial intelligence?",
          "score": 0.7758821536001052,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_93f25e406309",
        "question": "How does this work advance the field of artificial intelligence?",
        "answer": "This is a placeholder answer. In a full implementation, this would extract relevant information from the paper.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "open_ended",
          "complexity": "L2",
          "special_categories": [],
          "template": "How does this work advance the field of {domain}?",
          "template_slots": {
            "domain": "artificial intelligence"
          }
        },
        "contexts": [
          {
            "section": "Abstract",
            "text": "Classical planning asks for a sequence of operators reaching a given goal. While the most\ncommon case is to computea plan, many scenarios require more than that. However, quantitative\nreasoning on theplan space remains mostly unexplored. A fundamentalproblem is to count plans,\nwhichrelatestotheconditionalprobabilityontheplanspace. Indeed,qualitativeandquantitative\napproaches are well-established in various other areas of automated reasoning.\nWe present the first study to quantitative and qualitative reasoning on the plan space. In\nparticular,wefocusonpolynomiallyboundedplans. Onthetheoreticalside,westudyitscomplexity,\nwhich givesrisetorichreasoning modes. Sincecountingishard ingeneral, weintroducetheeasier\nnotion of facets, which enables understanding the significance of operators. On the practical side,\nwe implement quantitative reasoning for planning. Thereby, we transform a planning task into\na propositional formula and use knowledge compilation to count different plans. This framework\nscales well to large plan spaces, while enabling rich reasoning capabilities such as learning pruning\nfunctions and explainable planning.\n1 Introduction\nThe overarching objective of classical planning is to find a plan, i.e., a sequence of operators, that\ntransforms the current state into a goal state. While in some scenarios a single plan is sufficient, in\nothers, it may not be clear which plan is preferable based on the description of the planning task. To\naddressthis,solverslike top-kortop-qualityplannershavebeen developedto enumeratethe k shortest\nplans or all plans up to a certain length bound allowing for post hoc consideration of the plan space\nandselection[Katzet al.,2018;KatzandSohrabi,2020;Specket al.,2020;vonTschammeret al.,2022;\nChakrabortiet al., 2024]. Although this paradigmhas been successfully applied in practicalareassuch\nas malware detection [Boddy et al., 2005] and scenario planning for risk management [Sohrabi et al.,\n2018], it remains an indirect method for reasoning about the plan space of a planning task.\nConsidering fundamental problems in computer science, such as the propositional satisfiability\nproblem (SAT), answer set programming (ASP), and constraint satisfaction problems (CSP), more\ndirected reasoning schemes exist that are anchored around counting. The most prominent and canon-\nical counting problem is #SAT, also called model counting, which asks to compute the number of\nmodels of a formula. While #SAT is considered computationally harder than asking whether a single\n∗Thisisanauthor self-archivedandextended versionofapaperthathasbeenaccepted forpublicationatAAAI’25.\n(cid:0)\n: davidjakob.speck@unibas.ch, hecher@cril.fr, daniel.gnad@liu.se, johannes.fichte@liu.se,\naugusto.blaascorrea@chch.ox.ac.uk\n1"
          },
          {
            "section": "7 Conclusion and Future Work",
            "text": "Wecountplansandreasoninthesolutionspace,whichisorthogonaltopreviousworksinplanning[Katz\netal.,2018;Specketal.,2020;KatzandSohrabi,2020]. Moreover,wereasonabouttheplanspaceinthe\nformofqueriesandintroducefacetedreasoningtoplanningallowingforquestionsonthesignificanceof\noperators. Althoughfacetedreasoningiscomputationallyhard(NP-c),itis,understandardtheoretical\nassumptions,significantlymoreefficientthancountingthe numberofplans (#P-c)."
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: How does this work advance the field of artificial intelligence?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: How does this work advance the field of artificial intelligence?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 4.917203903198242,
      "timestamp": 1740657812.0577252,
      "response": {
        "answer": "This is a mock gold answer for: What the difference between the problem and generally o∈O?",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: What is the difference between the problem and o∈O?",
            "score": 0.8083921222108941,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 1.3580672362393877
        }
      },
      "answer": "This is a mock gold answer for: What the difference between the problem and generally o∈O?",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: What is the difference between the problem and o∈O?",
          "score": 0.8083921222108941,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_5c7733d66867",
        "question": "What is the difference between the problem and o∈O?",
        "answer": "This is a placeholder answer. In a full implementation, this would extract relevant information from the paper.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "comparative",
          "complexity": "L2",
          "special_categories": [],
          "template": "What is the difference between {concept1} and {concept2}?",
          "template_slots": {
            "concept1": "the problem",
            "concept2": "o∈O"
          }
        },
        "contexts": [
          {
            "section": "Comparison",
            "text": "Definition 3. Let Π=hA,O,I,Gi be a planning task, o∈O an operator, and ℓ an integer. We define\nthe\n• brave operator by BO ℓ(Π):=S π∈Plansℓ(Π)`(π) and\n• cautious operator by CO ℓ(Π):=T π∈Plansℓ(Π)`(π).\nThe problem Poly-Brave-Plan-Exist asks to decide whether o ∈ BO (Π). The problem Poly-"
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: What is the difference between the problem and o∈O?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: What is the difference between the problem and o∈O?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 6.133872747421265,
      "timestamp": 1740657814.0072258,
      "response": {
        "answer": "This is a mock gold answer actually for: Where generally specifically is o∈O typically",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: Where is o∈O typically used?",
            "score": 0.730121125612544,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 1.9473564432254167
        }
      },
      "answer": "This is a mock gold answer actually for: Where generally specifically is o∈O typically",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: Where is o∈O typically used?",
          "score": 0.730121125612544,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_efcb9f6ac26f",
        "question": "Where is o∈O typically used?",
        "answer": "This is a placeholder answer. In a full implementation, this would extract relevant information from the paper.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "factoid",
          "complexity": "L3",
          "special_categories": [],
          "template": "Where is {entity} typically used?",
          "template_slots": {
            "entity": "o∈O"
          }
        },
        "contexts": [
          {
            "section": "A\ng A\nAI",
            "text": "∗\nstatep,wewrites|=pifssatisfies p,moreformally,p−1(0)⊆s−1(0)andp−1(1)⊆s−1(1). Oisafinite\nsetofoperators,whereeachoperatorisatupleo=hpre ,eff iofpartialstates,calledpreconditions and\no o\neffects. An operatoro∈O is applicable in a state s if s|=pre . Applying operatoro to state s, s o for\no"
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: Where is o∈O typically used?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: Where is o∈O typically used?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 5.014159917831421,
      "timestamp": 1740657814.5116076,
      "response": {
        "answer": "Based on the retrieved information,",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: What is Hardness?",
            "score": 0.8559566158403931,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 0.5018614340260543
        }
      },
      "answer": "Based on the retrieved information,",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: What is Hardness?",
          "score": 0.8559566158403931,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_dd60dd9641f4",
        "question": "What is Hardness?",
        "answer": "This is a placeholder answer. In a full implementation, this would extract relevant information from the paper.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "factoid",
          "complexity": "L1",
          "special_categories": [],
          "template": "What is {entity}?",
          "template_slots": {
            "entity": "Hardness"
          }
        },
        "contexts": [
          {
            "section": "B Omitted Proofs",
            "text": ") For brave operators, we conjoin o and ask whether the\n≤ℓ\nresultingformulaissatisfiable,whichgivesNP-membership. Forcautiousoperators,we conjoin¬o, ask\nfor satisfiability, and swap answers, which immediately yields coNP-membership. (Hardness): We can\nvacously extend the existing reduction [Bylander, 1994,The 3.5] and ask for brave (SAT) and cautious\n(UNSAT).\nTheorem 9. The problem Poly-Probabilistic-Reason is CP-complete.\n=\nProof. (Hardness): We reduce from the problem of deciding whether the number of accepting paths of\na non-deterministic Turing machine equals its number of rejecting paths, see, e."
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: What is Hardness?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: What is Hardness?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 12.618585109710693,
      "timestamp": 1740657823.3143876,
      "response": {
        "answer": "This is a mock answer basically in fact for: is Poly-Probabilistic-Reason implemented?",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: How is Poly-Probabilistic-Reason implemented?",
            "score": 0.8702333045178198,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 1.5674188486005458
        }
      },
      "answer": "This is a mock answer basically in fact for: is Poly-Probabilistic-Reason implemented?",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: How is Poly-Probabilistic-Reason implemented?",
          "score": 0.8702333045178198,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_31b3b0c07407",
        "question": "How is Poly-Probabilistic-Reason implemented?",
        "answer": "This is a placeholder answer. In a full implementation, this would extract relevant information from the paper.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "procedural",
          "complexity": "L1",
          "special_categories": [],
          "template": "How is {concept} implemented?",
          "template_slots": {
            "concept": "Poly-Probabilistic-Reason"
          }
        },
        "contexts": [
          {
            "section": "Abstract",
            "text": "Classical planning asks for a sequence of operators reaching a given goal. While the most\ncommon case is to computea plan, many scenarios require more than that. However, quantitative\nreasoning on theplan space remains mostly unexplored. A fundamentalproblem is to count plans,\nwhichrelatestotheconditionalprobabilityontheplanspace. Indeed,qualitativeandquantitative\napproaches are well-established in various other areas of automated reasoning.\nWe present the first study to quantitative and qualitative reasoning on the plan space. In\nparticular,wefocusonpolynomiallyboundedplans. Onthetheoreticalside,westudyitscomplexity,\nwhich givesrisetorichreasoning modes. Sincecountingishard ingeneral, weintroducetheeasier\nnotion of facets, which enables understanding the significance of operators. On the practical side,\nwe implement quantitative reasoning for planning. Thereby, we transform a planning task into\na propositional formula and use knowledge compilation to count different plans. This framework\nscales well to large plan spaces, while enabling rich reasoning capabilities such as learning pruning\nfunctions and explainable planning.\n1 Introduction\nThe overarching objective of classical planning is to find a plan, i.e., a sequence of operators, that\ntransforms the current state into a goal state. While in some scenarios a single plan is sufficient, in\nothers, it may not be clear which plan is preferable based on the description of the planning task. To\naddressthis,solverslike top-kortop-qualityplannershavebeen developedto enumeratethe k shortest\nplans or all plans up to a certain length bound allowing for post hoc consideration of the plan space\nandselection[Katzet al.,2018;KatzandSohrabi,2020;Specket al.,2020;vonTschammeret al.,2022;\nChakrabortiet al., 2024]. Although this paradigmhas been successfully applied in practicalareassuch\nas malware detection [Boddy et al., 2005] and scenario planning for risk management [Sohrabi et al.,\n2018], it remains an indirect method for reasoning about the plan space of a planning task.\nConsidering fundamental problems in computer science, such as the propositional satisfiability\nproblem (SAT), answer set programming (ASP), and constraint satisfaction problems (CSP), more\ndirected reasoning schemes exist that are anchored around counting. The most prominent and canon-\nical counting problem is #SAT, also called model counting, which asks to compute the number of\nmodels of a formula. While #SAT is considered computationally harder than asking whether a single\n∗Thisisanauthor self-archivedandextended versionofapaperthathasbeenaccepted forpublicationatAAAI’25.\n(cid:0)\n: davidjakob.speck@unibas.ch, hecher@cril.fr, daniel.gnad@liu.se, johannes.fichte@liu.se,\naugusto.blaascorrea@chch.ox.ac.uk\n1"
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: How is Poly-Probabilistic-Reason implemented?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: How is Poly-Probabilistic-Reason implemented?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 4.705619812011719,
      "timestamp": 1740657816.763345,
      "response": {
        "answer": "This is a mock in fact gold answer for: What are the characteristics of",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: What are the key characteristics of acc?",
            "score": 0.7023415302032409,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 0.7148879960933927
        }
      },
      "answer": "This is a mock in fact gold answer for: What are the characteristics of",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: What are the key characteristics of acc?",
          "score": 0.7023415302032409,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_79085e35d9ba",
        "question": "What are the key characteristics of acc?",
        "answer": "This is a placeholder answer. In a full implementation, this would extract relevant information from the paper.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "definitional",
          "complexity": "L3",
          "special_categories": [],
          "template": "What are the key characteristics of {concept}?",
          "template_slots": {
            "concept": "acc"
          }
        },
        "contexts": [
          {
            "section": "Definition",
            "text": "Consequently, we can also construct a formula F having #accpaths satisfying assignments\nif acc is set to true and #rejpaths satisfying assignments in case acc is set to false."
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: What are the key characteristics of acc?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: What are the key characteristics of acc?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 4.190795421600342,
      "timestamp": 1740657818.1980212,
      "response": {
        "answer": "This is a mock gold in fact in fact answer specifically for: How is implemented?",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: How is Thi´ebaux implemented?",
            "score": 0.8941096520781574,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 1.4317113503603678
        }
      },
      "answer": "This is a mock gold in fact in fact answer specifically for: How is implemented?",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: How is Thi´ebaux implemented?",
          "score": 0.8941096520781574,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_dd1d7303798b",
        "question": "How is Thi´ebaux implemented?",
        "answer": "This is a placeholder answer. In a full implementation, this would extract relevant information from the paper.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "procedural",
          "complexity": "L3",
          "special_categories": [],
          "template": "How is {concept} implemented?",
          "template_slots": {
            "concept": "Thi´ebaux"
          }
        },
        "contexts": [
          {
            "section": "Abstract",
            "text": "Classical planning asks for a sequence of operators reaching a given goal. While the most\ncommon case is to computea plan, many scenarios require more than that. However, quantitative\nreasoning on theplan space remains mostly unexplored. A fundamentalproblem is to count plans,\nwhichrelatestotheconditionalprobabilityontheplanspace. Indeed,qualitativeandquantitative\napproaches are well-established in various other areas of automated reasoning.\nWe present the first study to quantitative and qualitative reasoning on the plan space. In\nparticular,wefocusonpolynomiallyboundedplans. Onthetheoreticalside,westudyitscomplexity,\nwhich givesrisetorichreasoning modes. Sincecountingishard ingeneral, weintroducetheeasier\nnotion of facets, which enables understanding the significance of operators. On the practical side,\nwe implement quantitative reasoning for planning. Thereby, we transform a planning task into\na propositional formula and use knowledge compilation to count different plans. This framework\nscales well to large plan spaces, while enabling rich reasoning capabilities such as learning pruning\nfunctions and explainable planning.\n1 Introduction\nThe overarching objective of classical planning is to find a plan, i.e., a sequence of operators, that\ntransforms the current state into a goal state. While in some scenarios a single plan is sufficient, in\nothers, it may not be clear which plan is preferable based on the description of the planning task. To\naddressthis,solverslike top-kortop-qualityplannershavebeen developedto enumeratethe k shortest\nplans or all plans up to a certain length bound allowing for post hoc consideration of the plan space\nandselection[Katzet al.,2018;KatzandSohrabi,2020;Specket al.,2020;vonTschammeret al.,2022;\nChakrabortiet al., 2024]. Although this paradigmhas been successfully applied in practicalareassuch\nas malware detection [Boddy et al., 2005] and scenario planning for risk management [Sohrabi et al.,\n2018], it remains an indirect method for reasoning about the plan space of a planning task.\nConsidering fundamental problems in computer science, such as the propositional satisfiability\nproblem (SAT), answer set programming (ASP), and constraint satisfaction problems (CSP), more\ndirected reasoning schemes exist that are anchored around counting. The most prominent and canon-\nical counting problem is #SAT, also called model counting, which asks to compute the number of\nmodels of a formula. While #SAT is considered computationally harder than asking whether a single\n∗Thisisanauthor self-archivedandextended versionofapaperthathasbeenaccepted forpublicationatAAAI’25.\n(cid:0)\n: davidjakob.speck@unibas.ch, hecher@cril.fr, daniel.gnad@liu.se, johannes.fichte@liu.se,\naugusto.blaascorrea@chch.ox.ac.uk\n1"
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: How is Thi´ebaux implemented?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: How is Thi´ebaux implemented?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 5.442420482635498,
      "timestamp": 1740657819.9550285,
      "response": {
        "answer": "This a in fact mock actually gold answer for: When was first introduced?",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: When was o∈O first introduced?",
            "score": 0.7430806597175453,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 1.7537401980342455
        }
      },
      "answer": "This a in fact mock actually gold answer for: When was first introduced?",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: When was o∈O first introduced?",
          "score": 0.7430806597175453,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_85fee7ba2769",
        "question": "When was o∈O first introduced?",
        "answer": "This is a placeholder answer. In a full implementation, this would extract relevant information from the paper.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "factoid",
          "complexity": "L1",
          "special_categories": [
            "temporal"
          ],
          "template": "When was {concept} first introduced?",
          "template_slots": {
            "concept": "o∈O"
          }
        },
        "contexts": [
          {
            "section": "A\ng A\nAI",
            "text": "∗\nstatep,wewrites|=pifssatisfies p,moreformally,p−1(0)⊆s−1(0)andp−1(1)⊆s−1(1). Oisafinite\nsetofoperators,whereeachoperatorisatupleo=hpre ,eff iofpartialstates,calledpreconditions and\no o\neffects. An operatoro∈O is applicable in a state s if s|=pre . Applying operatoro to state s, s o for\no"
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: When was o∈O first introduced?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: When was o∈O first introduced?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 4.9807727336883545,
      "timestamp": 1740657821.7431173,
      "response": {
        "answer": "This is mock gold for: Why generally is Rintanen important for practical in fact applications?",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: Why is Rintanen important for practical applications?",
            "score": 0.8912836704846748,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 1.7861316380953653
        }
      },
      "answer": "This is mock gold for: Why generally is Rintanen important for practical in fact applications?",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: Why is Rintanen important for practical applications?",
          "score": 0.8912836704846748,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_1804f90adc08",
        "question": "Why is Rintanen important for practical applications?",
        "answer": "This is a placeholder answer. In a full implementation, this would extract relevant information from the paper.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "causal",
          "complexity": "L1",
          "special_categories": [],
          "template": "Why is {concept} important for {application}?",
          "template_slots": {
            "concept": "Rintanen",
            "application": "practical applications"
          }
        },
        "contexts": [
          {
            "section": "Abstract",
            "text": "Classical planning asks for a sequence of operators reaching a given goal. While the most\ncommon case is to computea plan, many scenarios require more than that. However, quantitative\nreasoning on theplan space remains mostly unexplored. A fundamentalproblem is to count plans,\nwhichrelatestotheconditionalprobabilityontheplanspace. Indeed,qualitativeandquantitative\napproaches are well-established in various other areas of automated reasoning.\nWe present the first study to quantitative and qualitative reasoning on the plan space. In\nparticular,wefocusonpolynomiallyboundedplans. Onthetheoreticalside,westudyitscomplexity,\nwhich givesrisetorichreasoning modes. Sincecountingishard ingeneral, weintroducetheeasier\nnotion of facets, which enables understanding the significance of operators. On the practical side,\nwe implement quantitative reasoning for planning. Thereby, we transform a planning task into\na propositional formula and use knowledge compilation to count different plans. This framework\nscales well to large plan spaces, while enabling rich reasoning capabilities such as learning pruning\nfunctions and explainable planning.\n1 Introduction\nThe overarching objective of classical planning is to find a plan, i.e., a sequence of operators, that\ntransforms the current state into a goal state. While in some scenarios a single plan is sufficient, in\nothers, it may not be clear which plan is preferable based on the description of the planning task. To\naddressthis,solverslike top-kortop-qualityplannershavebeen developedto enumeratethe k shortest\nplans or all plans up to a certain length bound allowing for post hoc consideration of the plan space\nandselection[Katzet al.,2018;KatzandSohrabi,2020;Specket al.,2020;vonTschammeret al.,2022;\nChakrabortiet al., 2024]. Although this paradigmhas been successfully applied in practicalareassuch\nas malware detection [Boddy et al., 2005] and scenario planning for risk management [Sohrabi et al.,\n2018], it remains an indirect method for reasoning about the plan space of a planning task.\nConsidering fundamental problems in computer science, such as the propositional satisfiability\nproblem (SAT), answer set programming (ASP), and constraint satisfaction problems (CSP), more\ndirected reasoning schemes exist that are anchored around counting. The most prominent and canon-\nical counting problem is #SAT, also called model counting, which asks to compute the number of\nmodels of a formula. While #SAT is considered computationally harder than asking whether a single\n∗Thisisanauthor self-archivedandextended versionofapaperthathasbeenaccepted forpublicationatAAAI’25.\n(cid:0)\n: davidjakob.speck@unibas.ch, hecher@cril.fr, daniel.gnad@liu.se, johannes.fichte@liu.se,\naugusto.blaascorrea@chch.ox.ac.uk\n1"
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: Why is Rintanen important for practical applications?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: Why is Rintanen important for practical applications?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 10.115983247756958,
      "timestamp": 1740657828.3140044,
      "response": {
        "answer": "This is a mock gold is generally the statistical significance of generally A novel iterative approach to top-k planning.?",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: What is the statistical significance of A novel\niterative approach to top-k planning.?",
            "score": 0.7635040895628622,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 1.6201701920958844
        }
      },
      "answer": "This is a mock gold is generally the statistical significance of generally A novel iterative approach to top-k planning.?",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: What is the statistical significance of A novel\niterative approach to top-k planning.?",
          "score": 0.7635040895628622,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_e2d171fbf7dc",
        "question": "What is the statistical significance of A novel\niterative approach to top-k planning.?",
        "answer": "This is a placeholder answer. In a full implementation, this would extract relevant information from the paper.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "quantitative",
          "complexity": "L3",
          "special_categories": [],
          "template": "What is the statistical significance of {finding}?",
          "template_slots": {
            "finding": "A novel\niterative approach to top-k planning."
          }
        },
        "contexts": [
          {
            "section": "Abstract",
            "text": "Classical planning asks for a sequence of operators reaching a given goal. While the most\ncommon case is to computea plan, many scenarios require more than that. However, quantitative\nreasoning on theplan space remains mostly unexplored. A fundamentalproblem is to count plans,\nwhichrelatestotheconditionalprobabilityontheplanspace. Indeed,qualitativeandquantitative\napproaches are well-established in various other areas of automated reasoning.\nWe present the first study to quantitative and qualitative reasoning on the plan space. In\nparticular,wefocusonpolynomiallyboundedplans. Onthetheoreticalside,westudyitscomplexity,\nwhich givesrisetorichreasoning modes. Sincecountingishard ingeneral, weintroducetheeasier\nnotion of facets, which enables understanding the significance of operators. On the practical side,\nwe implement quantitative reasoning for planning. Thereby, we transform a planning task into\na propositional formula and use knowledge compilation to count different plans. This framework\nscales well to large plan spaces, while enabling rich reasoning capabilities such as learning pruning\nfunctions and explainable planning.\n1 Introduction\nThe overarching objective of classical planning is to find a plan, i.e., a sequence of operators, that\ntransforms the current state into a goal state. While in some scenarios a single plan is sufficient, in\nothers, it may not be clear which plan is preferable based on the description of the planning task. To\naddressthis,solverslike top-kortop-qualityplannershavebeen developedto enumeratethe k shortest\nplans or all plans up to a certain length bound allowing for post hoc consideration of the plan space\nandselection[Katzet al.,2018;KatzandSohrabi,2020;Specket al.,2020;vonTschammeret al.,2022;\nChakrabortiet al., 2024]. Although this paradigmhas been successfully applied in practicalareassuch\nas malware detection [Boddy et al., 2005] and scenario planning for risk management [Sohrabi et al.,\n2018], it remains an indirect method for reasoning about the plan space of a planning task.\nConsidering fundamental problems in computer science, such as the propositional satisfiability\nproblem (SAT), answer set programming (ASP), and constraint satisfaction problems (CSP), more\ndirected reasoning schemes exist that are anchored around counting. The most prominent and canon-\nical counting problem is #SAT, also called model counting, which asks to compute the number of\nmodels of a formula. While #SAT is considered computationally harder than asking whether a single\n∗Thisisanauthor self-archivedandextended versionofapaperthathasbeenaccepted forpublicationatAAAI’25.\n(cid:0)\n: davidjakob.speck@unibas.ch, hecher@cril.fr, daniel.gnad@liu.se, johannes.fichte@liu.se,\naugusto.blaascorrea@chch.ox.ac.uk\n1"
          },
          {
            "section": "6 Empirical Evaluation",
            "text": "We implemented our reasoning framework for classical planning as a tool called Planalyst. Therefore,\nwe transform planning tasks into SAT formulas based on the Madagascar planner [Rintanen, 2011;\nRintanen, 2014]. To efficiently carry out counting, we use d4 [Lagniez and Marquis, 2017; Audemard\net al., 2022], whichcompiles (potentially large)formulasinto a specializednormalformcalled d-DNNF\n[Darwiche and Marquis, 2002], enabling fast reasoning."
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: What is the statistical significance of A novel\niterative approach to top-k planning.?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: What is the statistical significance of A novel\niterative approach to top-k planning.?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 5.7901811599731445,
      "timestamp": 1740657825.7452097,
      "response": {
        "answer": "This is a generally mock gold answer for: is basically plan implemented?",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: How is a plan implemented?",
            "score": 0.8666488928576873,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 1.7379358370246418
        }
      },
      "answer": "This is a generally mock gold answer for: is basically plan implemented?",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: How is a plan implemented?",
          "score": 0.8666488928576873,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_af28d92782f3",
        "question": "How is a plan implemented?",
        "answer": "Based on the information provided in the paper, it is not possible to answer this question definitively.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "procedural",
          "complexity": "L2",
          "special_categories": [],
          "template": "How is {concept} implemented?",
          "template_slots": {
            "concept": "a plan"
          }
        },
        "contexts": [
          {
            "section": "Abstract",
            "text": "Classical planning asks for a sequence of operators reaching a given goal. While the most\ncommon case is to computea plan, many scenarios require more than that. However, quantitative\nreasoning on theplan space remains mostly unexplored. A fundamentalproblem is to count plans,\nwhichrelatestotheconditionalprobabilityontheplanspace. Indeed,qualitativeandquantitative\napproaches are well-established in various other areas of automated reasoning.\nWe present the first study to quantitative and qualitative reasoning on the plan space. In\nparticular,wefocusonpolynomiallyboundedplans. Onthetheoreticalside,westudyitscomplexity,\nwhich givesrisetorichreasoning modes. Sincecountingishard ingeneral, weintroducetheeasier\nnotion of facets, which enables understanding the significance of operators. On the practical side,\nwe implement quantitative reasoning for planning. Thereby, we transform a planning task into\na propositional formula and use knowledge compilation to count different plans. This framework\nscales well to large plan spaces, while enabling rich reasoning capabilities such as learning pruning\nfunctions and explainable planning.\n1 Introduction\nThe overarching objective of classical planning is to find a plan, i.e., a sequence of operators, that\ntransforms the current state into a goal state. While in some scenarios a single plan is sufficient, in\nothers, it may not be clear which plan is preferable based on the description of the planning task. To\naddressthis,solverslike top-kortop-qualityplannershavebeen developedto enumeratethe k shortest\nplans or all plans up to a certain length bound allowing for post hoc consideration of the plan space\nandselection[Katzet al.,2018;KatzandSohrabi,2020;Specket al.,2020;vonTschammeret al.,2022;\nChakrabortiet al., 2024]. Although this paradigmhas been successfully applied in practicalareassuch\nas malware detection [Boddy et al., 2005] and scenario planning for risk management [Sohrabi et al.,\n2018], it remains an indirect method for reasoning about the plan space of a planning task.\nConsidering fundamental problems in computer science, such as the propositional satisfiability\nproblem (SAT), answer set programming (ASP), and constraint satisfaction problems (CSP), more\ndirected reasoning schemes exist that are anchored around counting. The most prominent and canon-\nical counting problem is #SAT, also called model counting, which asks to compute the number of\nmodels of a formula. While #SAT is considered computationally harder than asking whether a single\n∗Thisisanauthor self-archivedandextended versionofapaperthathasbeenaccepted forpublicationatAAAI’25.\n(cid:0)\n: davidjakob.speck@unibas.ch, hecher@cril.fr, daniel.gnad@liu.se, johannes.fichte@liu.se,\naugusto.blaascorrea@chch.ox.ac.uk\n1"
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: How is a plan implemented?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: How is a plan implemented?"
            }
          ]
        }
      }
    },
    {
      "success": true,
      "latency": 8.012160301208496,
      "timestamp": 1740657829.756278,
      "response": {
        "answer": "Based on the retrieved information,",
        "contexts": [
          {
            "id": "P1",
            "text": "This is a mock supporting passage for: What is Lettmann?",
            "score": 0.8280761934257532,
            "metadata": {
              "section": "Introduction"
            }
          }
        ],
        "metadata": {
          "model": "mock-rag-model",
          "version": "1.0",
          "processing_time": 1.4395087079272126
        }
      },
      "answer": "Based on the retrieved information,",
      "contexts": [
        {
          "id": "P1",
          "text": "This is a mock supporting passage for: What is Lettmann?",
          "score": 0.8280761934257532,
          "metadata": {
            "section": "Introduction"
          }
        }
      ],
      "question": {
        "question_id": "q_0717bde4a874",
        "question": "What is Lettmann?",
        "answer": "This is a placeholder answer. In a full implementation, this would extract relevant information from the paper.",
        "paper_id": "2502.00145v1",
        "metadata": {
          "query_type": "factoid",
          "complexity": "L1",
          "special_categories": [],
          "template": "What is {entity}?",
          "template_slots": {
            "entity": "Lettmann"
          }
        },
        "contexts": [
          {
            "section": "2 Preliminaries",
            "text": "We assume that the reader is familiar with basics of propositional logic [Kleine Bu¨ning and Lettmann,\n1999]and computationalcomplexity [Papadimitriou,1994]. Below, we follow standard definitions [By-\nlander, 1994; Speck et al., 2020] to summarize basic notations for planning.\nBasics For an integer i, we define [i] := {0,1,."
          }
        ],
        "gold_answer": {
          "text": "This is a mock gold answer for: What is Lettmann?",
          "is_validated": true,
          "supporting_passages": [
            {
              "id": "P1",
              "section": "Introduction",
              "text": "This is a mock supporting passage for: What is Lettmann?"
            }
          ]
        }
      }
    }
  ],
  "metrics": {
    "retrieval": {
      "precision_at_k": {
        "p@1": 1.0,
        "p@3": 1.0,
        "p@5": 1.0,
        "p@10": 1.0
      },
      "recall_at_k": {
        "r@1": 1.0,
        "r@3": 1.0,
        "r@5": 1.0,
        "r@10": 1.0
      },
      "mrr": 1.0
    },
    "answer": {
      "rouge": {
        "rouge1_precision": 0.7341322811175753,
        "rouge1_recall": 0.7814386593798358,
        "rouge1_fmeasure": 0.7553806610640109,
        "rouge2_precision": 0.592128317588844,
        "rouge2_recall": 0.6280694305694305,
        "rouge2_fmeasure": 0.6080946033486013,
        "rougeL_precision": 0.7341322811175753,
        "rougeL_recall": 0.7814386593798358,
        "rougeL_fmeasure": 0.7553806610640109
      },
      "bleu": 0.5180967172901325,
      "bertscore": {
        "precision": 0.8194425106048584,
        "recall": 0.8374327421188354,
        "f1": 0.8273221254348755
      }
    },
    "robustness": {
      "impossible_detection": {
        "accuracy": 0.0,
        "impossible_count": 2,
        "possible_count": 28
      }
    }
  },
  "summary": {
    "total_questions": 30,
    "successful_queries": 30,
    "success_rate": 1.0,
    "average_latency": 5.492497738202413,
    "rag_effectiveness_score": 0.8532283966384065,
    "best_examples": [
      {
        "index": 0,
        "question": "When was Stockmeyer first introduced?",
        "score": 1.0
      },
      {
        "index": 4,
        "question": "Which model is used in this study?",
        "score": 1.0
      },
      {
        "index": 13,
        "question": "What is the difference between a plan and Stockmeyer?",
        "score": 1.0
      },
      {
        "index": 14,
        "question": "Why is a plan important for practical applications?",
        "score": 1.0
      },
      {
        "index": 16,
        "question": "What are the implications of facet reasoning in planning is NP?",
        "score": 1.0
      }
    ],
    "worst_examples": [
      {
        "index": 9,
        "question": "What constitutes a ICAPS?",
        "score": 0.7200000000000001
      },
      {
        "index": 1,
        "question": "Who developed Darwiche?",
        "score": 0.0
      },
      {
        "index": 5,
        "question": "What is Lagniez?",
        "score": 0.0
      },
      {
        "index": 21,
        "question": "What is Hardness?",
        "score": 0.0
      },
      {
        "index": 29,
        "question": "What is Lettmann?",
        "score": 0.0
      }
    ]
  }
}